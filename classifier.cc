#include <iostream>
#include <fstream>
#include <sstream>
#include <stdlib.h>
#include <string>
#include <tuple>
#include <algorithm>
#include <unordered_set>
#include <math.h>

#include "dictionary.hh"

using namespace std;

int main(int argc, char **argv) {
	if (argc < 3) {
		cout << "usage: " << argv[0]
		<< " <training data filename (as generated by the trainer)>"
		<< " <documents filename (.te)>"
		<< endl;
		return EXIT_FAILURE;
	}

	// Check training data file
	char *training_data_filename = argv[1];
	ifstream f_train(training_data_filename);
	if (!f_train.good()) {
		cerr << "ERROR: Opening file '"
		<< training_data_filename << "' failed."
		<< endl;
		return EXIT_FAILURE;
	}

	// Check document filename
	char *documents_filename = argv[2];
	ifstream f_doc(documents_filename);
	if (!f_doc.good()) {
		cerr << "ERROR: Opening file '"
		<< documents_filename << "' failed."
		<< endl;
		return EXIT_FAILURE;
	}

	// Dictionary
	dictionary *dict = new dictionary();

	// Class prior probabilities
	typedef map<string, double> class_prior_probabilities_map;
	class_prior_probabilities_map class_prior_probabilities;

	// Class count model Poisson parameters
	typedef map<string, double> class_poisson_map;
	class_poisson_map class_poisson;
	
	// Word frequencies per class
	typedef map<unsigned int, double> word_freq_map;
	typedef map<string, word_freq_map> class_word_freq_map;
	class_word_freq_map word_freq;

	// Iterate training data file line by line (each line contains data for one class)
	// to build the word freq map
	string current_class;
	while (getline(f_train, current_class)) {
		// Tokenize the line
		istringstream iss(current_class);
		
		// Class name
		string class_name;
		iss >> class_name;

		// p(c)
		double class_prior_probability;
		iss >> class_prior_probability;
		class_prior_probabilities[class_name] = class_prior_probability;

		// p(N|c) Poisson parameter
		double count_model_poisson;
		iss >> count_model_poisson;
		class_poisson[class_name] = count_model_poisson;

		string word;
		double relative_frequency;
		while (iss >> word) {
			// Relative frequency
			iss >> relative_frequency;

			// Get word id
			unsigned int word_id = dict->id(word);

			// Store information to map
			word_freq[class_name][word_id] = relative_frequency;
		}
	}

	// Type for storing the word counts in a given document
	typedef map<unsigned int, unsigned int> word_count_map;

	// Now read the documents file
	string document;
	while (getline(f_doc, document)) {
		// Tokenize the document
		istringstream iss(document);

		// Document name
		string document_name;
		iss >> document_name;

		// Document length (N)
		unsigned int document_length = 0;

		// Word counts (N_w)
		word_count_map word_counts;

		string word;
		unsigned int word_count;
		while (iss >> word) {
			// Word count
			iss >> word_count;

			// Get word id
			unsigned int word_id = dict->id(word);

			// Increase document length (i.e. total word count)
			document_length += word_count;

			// Store word count
			word_counts[word_id] = word_count;
		}

		// Now, for each class c calculate the probability p(c) * p(N|c) * p(N_1^W | N, c)
		// (slide 83)
		for (class_word_freq_map::iterator it = word_freq.begin(); it != word_freq.end(); it++) {
			string class_name = it->first;

			
		}
	}

}

