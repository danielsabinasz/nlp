#include <iostream>
#include <fstream>
#include <sstream>
#include <stdlib.h>
#include <string>
#include <tuple>
#include <algorithm>
#include <unordered_set>
#include <math.h>

#include "dictionary.hh"

using namespace std;

double log_factorial(int n) {
	double ret = 0;
	for (int k = n; k >= 2; k--) {
		ret += log(k);
	}
	return ret;
}

int main(int argc, char **argv) {
	if (argc < 3) {
		cout << "usage: " << argv[0]
		<< " <training data filename (as generated by the trainer)>"
		<< " <documents filename (.te)>"
		<< endl;
		return EXIT_FAILURE;
	}

	// Check training data file
	char *training_data_filename = argv[1];
	ifstream f_train(training_data_filename);
	if (!f_train.good()) {
		cerr << "ERROR: Opening file '"
		<< training_data_filename << "' failed."
		<< endl;
		return EXIT_FAILURE;
	}

	// Check document filename
	char *documents_filename = argv[2];
	ifstream f_doc(documents_filename);
	if (!f_doc.good()) {
		cerr << "ERROR: Opening file '"
		<< documents_filename << "' failed."
		<< endl;
		return EXIT_FAILURE;
	}

	// Dictionary
	dictionary *dict = new dictionary();

	// Class prior probabilities
	typedef map<string, double> class_prior_probabilities_map;
	class_prior_probabilities_map class_prior_probabilities;

	// Class count model Poisson parameters
	typedef map<string, double> class_poisson_map;
	class_poisson_map class_poisson;
	
	// Word frequencies per class
	typedef map<unsigned int, double> word_freq_map;
	typedef map<string, word_freq_map> class_word_freq_map;
	class_word_freq_map word_freq;

	// Iterate training data file line by line (each line contains data for one class)
	// to build the word freq map
	string current_class;
	while (getline(f_train, current_class)) {
		// Tokenize the line
		istringstream iss(current_class);
		
		// Class name
		string class_name;
		iss >> class_name;

		// p(c)
		double class_prior_probability;
		iss >> class_prior_probability;
		class_prior_probabilities[class_name] = class_prior_probability;

		// p(N|c) Poisson parameter
		double count_model_poisson;
		iss >> count_model_poisson;
		class_poisson[class_name] = count_model_poisson;

		string word;
		double relative_frequency;
		while (iss >> word) {
			// Relative frequency
			iss >> relative_frequency;

			// Get word id
			unsigned int word_id = dict->id(word);

			// Store information to map
			word_freq[class_name][word_id] = relative_frequency;
		}
	}

	// Type for storing the word counts in a given document
	typedef map<unsigned int, unsigned int> word_count_map;

	// Now read the documents file
	int error_count = 0;
	int total_count = 0;
	int no_count = 0;
	string document;
	while (getline(f_doc, document)) {
		// Tokenize the document
		istringstream iss(document);

		// Document name
		string document_name;
		iss >> document_name;

		// Document class
		string document_class;
		iss >> document_class;

		// Document length (N)
		unsigned int document_length = 0;

		// Word counts (N_w)
		word_count_map word_counts;

		string word;
		unsigned int word_count;
		vector<unsigned int> word_ids;
		while (iss >> word) {
			// Word count
			iss >> word_count;

			// Get word id
			unsigned int word_id = dict->id(word);

			// Increase document length (i.e. total word count)
			document_length += word_count;

			// Store word count
			word_counts[word_id] = word_count;

			word_ids.push_back(word_id);
		}

		// Now, for each class c calculate the probability p(c) * p(N|c) * p(N_1^W | N, c)
		// (slide 83)
		// For faster and more exact calculation, we compute the negative logarithm of the probability instead
		double minimum_cost = numeric_limits<double>::infinity();
		string minimum_cost_class = "";
		for (class_word_freq_map::iterator it = word_freq.begin(); it != word_freq.end(); it++) {
			string class_name = it->first;

			double cost_prior = class_prior_probabilities[class_name];
			
			double lambda = class_poisson[class_name];
			double cost_length = lambda - document_length*log(lambda) + log_factorial(document_length);

			double current_cost = cost_prior + cost_length;
			for (vector<unsigned int>::iterator it2 = word_ids.begin(); it2 != word_ids.end(); it2++) {
				unsigned int word_id = *it2;
				unsigned int word_count = word_counts[word_id];

				double word_cost;
				if (word_freq[class_name].count(word_id) == 0) {
					word_cost = numeric_limits<double>::infinity();
					continue;
				}
				else word_cost = word_freq[class_name][word_id];

				current_cost += word_count * word_cost;
			}

			if (current_cost < minimum_cost) {
				minimum_cost = current_cost;
				minimum_cost_class = class_name;
			}
		
		}

		total_count++;
		if (minimum_cost_class == "") no_count++;
		else if (document_class != minimum_cost_class) error_count++;
	}

	cout << "total: " << total_count << ", false: " << error_count << ", none: " << no_count << endl;

}

